# 中间件
<!-- GFM-TOC -->
* rabbitmq
  * [rabbitMQ的工作原理？](#rabbitMQ的工作原理？)
  * [如何保rabbitmq证消息的有序性？](#如何保rabbitmq证消息的有序性？)
* kafka
  * [kafka关键技术点？](#kafka关键技术点？)
  * [如何保kafka证消息的有序性？](#如何保kafka证消息的有序性？)
  * [kafka生产者分区策略？](#kafka生产者分区策略？)
  * [kafka消费者分区策略？](#kafka消费者分区策略？)
  * [分区数大于等于消费者数，消费者如何分配？](#分区数大于等于消费者数，消费者如何分配？)
<!-- GFM-TOC -->

## rabbitmq

### rabbitMQ的工作原理

#### 发送消息

* 生产者和Broker建立TCP连接。
* 生产者和Broker建立通道。
* 生产者通过通道消息发送给Broker，由Exchange将消息进行转发。
* Exchange将消息转发到指定的Queue（队列）

#### 接收消息

* 消费者和Broker建立TCP连接
* 消费者和Broker建立通道
* 消费者监听指定的Queue（队列）
* 当有消息到达Queue时Broker默认将消息推送给消费者。
* 消费者接收到消息。

### 如何保rabbitmq证消息的有序性

* 拆分多个 queue，每个 queue 一个 consumer；
* 一个 queue对应一个 consumer，再用内存队列做排队，然后分发给不worker处理。

## kafka

### kafka关键技术点

* 磁盘顺序写
* 消息批量发送
* 批量压缩
* 标准化二进制消息格式
* 页缓存
* 内存映射文件
* 零拷贝技术

### 如何保kafka证消息的有序性

* 一个 topic，一个 partition，一个 consumer；
* 消息发送到指定partition分区。

### kafka生产者分区策略

默认的分区策略：

* 如果在发消息的时候指定了分区，则消息投递到指定的分区。
* 如果没有指定分区，但是消息的key不为空，则基于key的哈希值来选择一个分区。
* 如果既没有指定分区，且消息的key也是空，则用轮询或随机的方式选择一个分区。

> 新版kafka默认为轮询策略

### kafka消费者分区策略

* 同一时刻，一条消息只能被组中的一个消费者实例消费，不同组之间的消费不产生影响
* 最理想的情况：一个消费者负责一个分区
* 分区数小于消费者数：一个消费者最多消费一个分区
* 分区数大于等于消费者数：一个消费者会负责多个分区

### 分区数大于等于消费者数，消费者如何分配

* range策略是基于每个主题的。假设有两个消费者C0和C1，两个主题t0和t1，每个主题有3个分区，分别是t0p0，t0p1，t0p2，t1p0，t1p1，t1p2，那么分配结果如下：
C0: [t0p0, t0p1, t1p0, t1p1]
C1: [t0p2, t1p2]

* 轮询分配策略是基于所有可用的消费者和所有可用的分区的。假设有两个消费者C0和C1，两个主题t0和t1，每个主题有3个分区，分别是t0p0，t0p1，t0p2，t1p0，t1p1，t1p2，那么分配结果如下：
C0: [t0p0, t0p2, t1p1]
C1: [t0p1, t1p0, t1p2]

使用RoundRobin策略有两个前提条件必须满足：

* 同一个Consumer Group里面的所有消费者的num.streams必须相等；
* 每个消费者订阅的主题必须相同。

### zookeeper节点类型

* 持久节点：节点创建后，会一直存在，不会因客户端会话失效而删除；
* 持久顺序节点：基本特性与持久节点一致，创建节点的过程中，zookeeper会在其名字后自动追加一个单调增长的数字后缀，作为新的节点名；
* 临时节点：客户端会话失效或连接关闭后，该节点会被自动删除，且不能再临时节点下面创建子节点；
* 临时顺序节点：基本特性与临时节点一致，创建节点的过程中，zookeeper会在其名字后自动追加一个单调增长的数字后缀，作为新的节点名；
