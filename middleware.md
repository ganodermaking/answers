# 中间件
## rabbitmq
### rabbitMQ的工作原理？
##### 发送消息
* 生产者和Broker建立TCP连接。
* 生产者和Broker建立通道。
* 生产者通过通道消息发送给Broker，由Exchange将消息进行转发。
* Exchange将消息转发到指定的Queue（队列）

##### 接收消息
* 消费者和Broker建立TCP连接
* 消费者和Broker建立通道
* 消费者监听指定的Queue（队列）
* 当有消息到达Queue时Broker默认将消息推送给消费者。
* 消费者接收到消息。

## kafka
### 如何保kafka证消息的有序性？
kafka：
*  一个 topic，一个 partition，一个 consumer；
*  消息发送到指定partition分区。

rabbitmq：
* 拆分多个 queue，每个 queue 一个 consumer；
* 一个 queue对应一个 consumer，再用内存队列做排队，然后分发给不worker处理。

### kafka生产者分区策略？
默认的分区策略：
* 如果在发消息的时候指定了分区，则消息投递到指定的分区。
* 如果没有指定分区，但是消息的key不为空，则基于key的哈希值来选择一个分区。
* 如果既没有指定分区，且消息的key也是空，则用轮询或随机的方式选择一个分区。

> 新版kafka默认为轮询策略

### kafka消费者分区策略？
* 同一时刻，一条消息只能被组中的一个消费者实例消费，不同组之间的消费不产生影响
* 最理想的情况：一个消费者负责一个分区
* 分区数小于消费者数：一个消费者最多消费一个分区
* 分区数大于等于消费者数：一个消费者会负责多个分区

### 分区数大于等于消费者数，消费者分区分配策略？
* range策略是基于每个主题的。假设有两个消费者C0和C1，两个主题t0和t1，每个主题有3个分区，分别是t0p0，t0p1，t0p2，t1p0，t1p1，t1p2，那么分配结果如下：
C0: [t0p0, t0p1, t1p0, t1p1]
C1: [t0p2, t1p2]

* 轮询分配策略是基于所有可用的消费者和所有可用的分区的。假设有两个消费者C0和C1，两个主题t0和t1，每个主题有3个分区，分别是t0p0，t0p1，t0p2，t1p0，t1p1，t1p2，那么分配结果如下：
C0: [t0p0, t0p2, t1p1]
C1: [t0p1, t1p0, t1p2]

使用RoundRobin策略有两个前提条件必须满足：
* 同一个Consumer Group里面的所有消费者的num.streams必须相等；
* 每个消费者订阅的主题必须相同。

### kafka关键技术点？
* 磁盘顺序写
* 消息批量发送
* 批量压缩
* 标准化二进制消息格式
* 页缓存
* 内存映射文件
* 零拷贝技术