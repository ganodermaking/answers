# 中间件
<!-- GFM-TOC -->
* rabbitmq
  * [RabbitMQ的工作原理](#RabbitMQ的工作原理)
  * [如何保rabbitmq证消息的有序性](#如何保rabbitmq证消息的有序性)
* kafka
  * [Kafka关键技术点](#Kafka关键技术点)
  * [Kafka磁盘顺序写](#Kafka磁盘顺序写)
  * [如何保kafka证消息的有序性](#如何保kafka证消息的有序性)
  * [Kafka生产者分区策略](#Kafka生产者分区策略)
  * [Kafka消费者分区策略](#Kafka消费者分区策略)
* Zookeeper
* 注册中心
  * [Eureka](#Eureka)
  * [Zookeeper](#Zookeeper)
  * [Eureka和ZooKeeper区别](#Eureka和ZooKeeper区别)
  * [Nacos](#Nacos)
* 配置中心
  * [百度Disconf](#百度Disconf)
  * [携程Apollo](#携程Apollo)
<!-- GFM-TOC -->

## rabbitmq
### RabbitMQ的工作原理
#### 发送消息
* 生产者和Broker建立TCP连接。
* 生产者和Broker建立通道。
* 生产者通过通道消息发送给Broker，由Exchange将消息进行转发。
* Exchange将消息转发到指定的Queue（队列）

#### 接收消息
* 消费者和Broker建立TCP连接
* 消费者和Broker建立通道
* 消费者监听指定的Queue（队列）
* 当有消息到达Queue时Broker默认将消息推送给消费者。
* 消费者接收到消息。

### 如何保rabbitmq证消息的有序性
* 拆分多个 queue，每个 queue 一个 consumer；
* 一个 queue对应一个 consumer，再用内存队列做排队，然后分发给不worker处理。

## Kafka关键技术点
Kafka是高吞吐低延迟的高并发、高性能的消息中间件。
* 磁盘顺序写
* 消息批量压缩发送
* 标准化二进制消息格式
* 页缓存
* 内存映射文件
* 零拷贝技术

#### Kafka磁盘顺序写
* 磁盘顺序写速度超过内存随机读写
* JVM的GC效率低，内存占用大，使用磁盘可以避免这一问题
* 系统冷启动后，磁盘上的缓存依然可用

### 如何保kafka证消息的有序性
* 一个 topic，一个 partition，一个 consumer；
* 消息发送到指定partition分区。

### Kafka生产者分区策略
默认的分区策略：
* 如果在发消息的时候指定了分区，则消息投递到指定的分区。
* 如果没有指定分区，但是消息的key不为空，则基于key的哈希值来选择一个分区。
* 如果既没有指定分区，且消息的key也是空，则用轮询或随机的方式选择一个分区。

> 新版kafka默认为轮询策略

### Kafka消费者分区策略
* 同一时刻，一条消息只能被组中的一个消费者实例消费，不同组之间的消费不产生影响
* 最理想的情况：一个消费者负责一个分区
* 分区数小于消费者数：一个消费者最多消费一个分区
* 分区数大于等于消费者数：一个消费者会负责多个分区

分区数大于等于消费者数，消费者如何分配：
* range策略是基于每个主题的。假设有两个消费者C0和C1，两个主题t0和t1，每个主题有3个分区，分别是t0p0，t0p1，t0p2，t1p0，t1p1，t1p2，那么分配结果如下：
C0: [t0p0, t0p1, t1p0, t1p1]
C1: [t0p2, t1p2]

* 轮询分配策略是基于所有可用的消费者和所有可用的分区的。假设有两个消费者C0和C1，两个主题t0和t1，每个主题有3个分区，分别是t0p0，t0p1，t0p2，t1p0，t1p1，t1p2，那么分配结果如下：
C0: [t0p0, t0p2, t1p1]
C1: [t0p1, t1p0, t1p2]

使用RoundRobin策略有两个前提条件必须满足：

* 同一个Consumer Group里面的所有消费者的num.streams必须相等；
* 每个消费者订阅的主题必须相同。

## Zookeeper
### 为什么zookeeper要部署基数台服务器
在容忍度是一样的情况下，出于资源节省的角度，

## 注册中心
### Eureka
支持AP，Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)，其中说明了，eureka是不满足强一致性，但还是会保证最终一致性。

### Zookeeper
支持CP，zookeeper在选举leader时，会停止服务，直到选举成功之后才会再次对外提供服务。zookeeper节点类型：
* 持久节点：节点创建后，会一直存在，不会因客户端会话失效而删除；
* 持久顺序节点：基本特性与持久节点一致，创建节点的过程中，zookeeper会在其名字后自动追加一个单调增长的数字后缀，作为新的节点名；
* 临时节点：客户端会话失效或连接关闭后，该节点会被自动删除，且不能再临时节点下面创建子节点；
* 临时顺序节点：基本特性与临时节点一致，创建节点的过程中，zookeeper会在其名字后自动追加一个单调增长的数字后缀，作为新的节点名。

### Eureka和ZooKeeper区别
eureka和zookeeper就是CAP定理中的实现，eureka(保证AP)，zookeeper(保证CP)。
* 选举期间整个zooKeeper集群都是不可用的。
* 只要有一台Eureka还在，就能保证注册服务可用。

> zookeeper master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。

eureka有一种自我保护机制，15分钟内超过85%的节点都没有正常的心跳，eureka认为客户端与注册中心出现网络故障。
* 不再从注册列表中移除因为长时间没有收到心跳而应该过期的服务。
* Eureka仍然能够提供服务注册和查询请求。
* 网络稳定时，当前实例新的注册信息才会被同步到其它节点上。

> CAP定理：C：数据一致性。A：服务可用性。P：分区容错性

### Nacos
同时支持AP和CP，同时还支持配置中心
> Nacos = Spring Cloud注册中心 + Spring Cloud配置中心

## 配置中心
### 百度Disconf
Disconf 可以为各种业务平台提供统一的配置管理服务。
* 支持配置（配置项+配置文件）的分布式化管理
* 配置发布统一化
* 极简的使用方式（注解式编程 或 XML代码无代码侵入模式）
* 低侵入性或无侵入性、强兼容性
* 需要Spring编程环境

#### Disconf怎么做到实时修改？
Disconf主要是依靠zookeeper的Watch机制来做配置实时修改的

#### Disconf怎么做到数据持久化？
在配置中心添加的配置数据都被持久化到了DB中，每次客户端启动的时候会调用Disconf的Http接口获取最新的配置。

### 携程Apollo
Apollo的基础模型：
* 用户在配置中心对配置进行修改并发布
* 配置中心通知Apollo客户端有配置更新
* Apollo客户端从配置中心拉取最新的配置、更新本地配置并通知到应用

### 阿里Diamond
### spring cloud config